<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>raisaliky ‚Äî –≤–∫—É—Å–Ω—ã–π Match-3</title>
<link rel="preload" href="1.png" as="image">
<link rel="preload" href="2.png" as="image">
<link rel="preload" href="3.png" as="image">
<link rel="preload" href="4.png" as="image">
<link rel="preload" href="5.png" as="image">
<link rel="preload" href="6.png" as="image">
<link rel="preload" href="bonus.png" as="image">
<link rel="preload" href="rewind.png" as="image">
<style>
  :root{
    --bg:#05070f;
    --panel:#101726dd;
    --panel-light:#151e33;
    --stroke:#253149;
    --accent:#9be7ff;
    --text:#f5f7fb;
    --muted:#a8b6d8;
    --tile:76px;
    --gap:12px;
  }
  *{box-sizing:border-box;font-family:'Inter',system-ui,-apple-system,"Segoe UI",Roboto,sans-serif;}
  html,body{height:100%;}
  body{
    margin:0;
    background:radial-gradient(circle at 15% 15%, #1c2a4d, transparent 50%),
               radial-gradient(circle at 85% 20%, #243a6b, transparent 55%),
               radial-gradient(circle at 35% 80%, #13203b, transparent 45%),
               var(--bg);
    color:var(--text);
    display:flex;align-items:center;justify-content:center;
    padding:18px;
  }
  .wrap{
    display:grid;
    grid-template-columns: minmax(280px, 330px) minmax(340px, 1fr);
    gap:20px;
    width:100%;
    max-width:1180px;
  }
  .panel{
    background:var(--panel);
    border:1px solid rgba(155,231,255,.2);
    box-shadow:0 25px 45px rgba(0,0,0,.45);
    padding:24px;
    border-radius:22px;
    backdrop-filter:blur(18px);
    display:flex;
    flex-direction:column;
    gap:20px;
  }
  h1{margin:0;font-size:26px;letter-spacing:0.02em;display:flex;align-items:center;gap:8px;}
  h1 span{font-size:30px;}
  .subtitle{margin:0;color:var(--muted);font-size:14px;line-height:1.5;}
  .hud{
    display:grid;
    grid-template-columns:repeat(2, minmax(0,1fr));
    gap:12px;
  }
  .stat{
    background:var(--panel-light);
    border:1px solid rgba(155,231,255,.22);
    border-radius:16px;
    padding:12px 14px;
    display:flex;
    flex-direction:column;
    gap:4px;
    min-height:78px;
    position:relative;
    overflow:hidden;
  }
  .stat::after{
    content:"";
    position:absolute;inset:-40% 50% auto -30%;
    height:130%;
    background:linear-gradient(120deg, rgba(155,231,255,.12), rgba(155,231,255,0));
    transform:skewX(-12deg);
    pointer-events:none;
  }
  .stat__label{font-size:13px;color:var(--muted);}
  .stat__value{font-size:28px;font-weight:700;display:flex;align-items:center;gap:6px;}
  .stat__accent{font-size:16px;color:var(--accent);}
  .progress{
    background:rgba(11,19,37,.6);
    border:1px solid rgba(155,231,255,.14);
    border-radius:999px;
    height:14px;
    overflow:hidden;
    position:relative;
  }
  .progress__fill{
    position:absolute;inset:0;
    background:linear-gradient(90deg,#48a9ff,#7ef3ff);
    width:0%;
    transition:width .35s ease;
  }
  .tools{
    display:flex;flex-wrap:wrap;gap:10px;
  }
  button{
    background:linear-gradient(135deg,#1d2a47,#152036);
    color:var(--text);
    border:1px solid rgba(155,231,255,.28);
    border-radius:14px;
    padding:10px 16px;
    font-weight:600;
    font-size:14px;
    cursor:pointer;
    display:inline-flex;
    gap:8px;
    align-items:center;
    transition:transform .18s ease, box-shadow .18s ease, border-color .18s ease;
  }
  button:hover:not(:disabled){
    transform:translateY(-1px);
    box-shadow:0 10px 25px rgba(0,0,0,.25);
    border-color:rgba(155,231,255,.45);
  }
  button:disabled{opacity:.4;cursor:not-allowed;}
  .tools__counter{display:flex;align-items:center;gap:6px;font-size:14px;color:var(--muted);padding:0 4px;}
  .inventory{
    background:rgba(11,19,37,.65);
    border:1px solid rgba(155,231,255,.18);
    border-radius:18px;
    padding:16px;
    display:flex;
    flex-direction:column;
    gap:12px;
  }
  .inventory h2{margin:0;font-size:16px;font-weight:600;letter-spacing:0.01em;}
  .inventory__list{display:flex;flex-wrap:wrap;gap:10px;min-height:54px;}
  .inventory__hint{margin:0;color:var(--muted);font-size:12px;line-height:1.4;}
  .inventory__empty{color:var(--muted);font-size:12px;opacity:.75;padding:6px 0;}
  .inventory__item{
    width:48px;height:48px;border-radius:14px;
    border:2px solid transparent;
    background:rgba(24,34,58,.88);
    display:grid;place-items:center;
    cursor:pointer;
    transition:border-color .2s ease, transform .2s ease;
  }
  .inventory__item img{width:32px;height:32px;object-fit:contain;}
  .inventory__item.active{border-color:#7ef3ff;box-shadow:0 0 0 3px rgba(126,243,255,.18);}
  .inventory__item:hover{transform:translateY(-1px);}
  main{position:relative;}
  .board{
    display:grid;
    gap:var(--gap);
    background:rgba(11,19,37,.55);
    border:1px solid rgba(155,231,255,.2);
    border-radius:22px;
    padding:var(--gap);
    position:relative;
    box-shadow:0 20px 40px rgba(0,0,0,.35);
  }
  .cell{
    width:var(--tile);height:var(--tile);
    border-radius:18px;
    background:linear-gradient(180deg,rgba(35,50,82,.75),rgba(15,20,35,.95));
    display:grid;place-items:center;
  }
  .tile{
    width:calc(var(--tile) - 10px);
    height:calc(var(--tile) - 10px);
    border-radius:16px;
    display:grid;place-items:center;
    user-select:none;
    cursor:pointer;
    border:5px solid transparent;
    background:linear-gradient(145deg,rgba(20,29,50,.92),rgba(10,15,30,.95));
    box-shadow:0 8px 16px rgba(0,0,0,.35);
    position:relative;
    transition:box-shadow .18s ease, transform .18s ease, border-color .18s ease;
  }
  .tile img{width:68%;height:68%;object-fit:contain;pointer-events:none;}
  .tile:hover{box-shadow:0 10px 22px rgba(0,0,0,.4);}
  .tile.selected{box-shadow:0 0 0 3px rgba(126,243,255,.5) inset, 0 10px 24px rgba(0,0,0,.4);}
  .tile--ghost{opacity:0;}
  .tile-ghost{
    position:fixed;
    z-index:40;
    border-radius:16px;
    pointer-events:none;
    transition:transform .2s cubic-bezier(.34,.78,.34,1.14);
    background:linear-gradient(145deg,rgba(20,29,50,.92),rgba(10,15,30,.95));
    border:5px solid transparent;
    box-shadow:0 10px 22px rgba(0,0,0,.45);
  }
  .tile-ghost img{width:68%;height:68%;object-fit:contain;}
  .toast{
    position:fixed;
    top:18px;left:50%;transform:translateX(-50%);
    background:rgba(15,22,40,.92);
    border:1px solid rgba(155,231,255,.25);
    padding:10px 16px;
    border-radius:14px;
    opacity:0;
    pointer-events:none;
    transition:opacity .25s ease, transform .25s ease;
    font-size:13px;
    box-shadow:0 14px 30px rgba(0,0,0,.35);
  }
  .toast.show{opacity:1;transform:translate(-50%,0);}
  .overlay{
    position:absolute;
    inset:0;
    background:rgba(5,8,16,.82);
    border-radius:22px;
    display:flex;
    align-items:center;
    justify-content:center;
    opacity:0;
    pointer-events:none;
    transition:opacity .3s ease;
  }
  .overlay.visible{opacity:1;pointer-events:auto;}
  .overlay__panel{
    background:rgba(14,22,39,.95);
    border:1px solid rgba(155,231,255,.35);
    padding:32px;
    border-radius:20px;
    text-align:center;
    max-width:320px;
    display:flex;
    flex-direction:column;
    gap:14px;
  }
  .overlay__panel h3{margin:0;font-size:22px;}
  .overlay__panel p{margin:0;color:var(--muted);font-size:14px;line-height:1.5;}
  @media (max-width:1024px){
    .wrap{grid-template-columns:1fr;}
    main{order:-1;}
    :root{--tile:70px;}
  }
  @media (max-width:620px){
    body{padding:12px;}
    :root{--tile:60px;--gap:10px;}
    .panel{padding:18px;}
    .hud{grid-template-columns:1fr 1fr;}
  }
</style>
</head>
<body>
<div class="wrap">
  <main>
    <div id="board" class="board" aria-label="–ü–æ–ª–µ"></div>
    <div id="overlay" class="overlay" aria-live="polite">
      <div class="overlay__panel">
        <h3>–í—Ä–µ–º—è –≤—ã—à–ª–æ!</h3>
        <p id="overlaySummary">–í—ã —Å–æ–±—Ä–∞–ª–∏ 0 —É–≥–æ—â–µ–Ω–∏–π.</p>
        <button id="overlayRestart">–ù–æ–≤–∞—è –ø–æ–ø—ã—Ç–∫–∞</button>
      </div>
    </div>
  </main>
  <section class="panel">
    <header>
      <h1><span>üêæ</span> raisaliky</h1>
      <p class="subtitle">
        –ü–µ—Ä–µ—Ç—è–≥–∏–≤–∞–π –∏–ª–∏ –∫–ª–∏–∫–∞–π –ø–æ —Å–æ—Å–µ–¥–Ω–∏–º –ø–ª–∏—Ç–∫–∞–º, —Å–æ–±–∏—Ä–∞–π —Ä—è–¥—ã. –ó–∞ 3 –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –ø–ª–∏—Ç–∫–∏ –ø–æ–¥—Ä—è–¥ ‚Äî ü•©, –∑–∞ 4 ‚Äî –¥–≤–µ, –∑–∞ 5 –∏ –±–æ–ª–µ–µ ‚Äî —Ç—Ä–∏.
        –ö–∞–∂–¥—ã–µ 10 —É–≥–æ—â–µ–Ω–∏–π –ø—Ä–µ–≤—Ä–∞—â–∞—é—Ç—Å—è –≤ —Å—É–Ω–¥—É–∫ —Å —Å–ª—É—á–∞–π–Ω–æ–π –ø–ª–∏—Ç–∫–æ–π. –ò—Å–ø–æ–ª—å–∑—É–π –µ—ë –≤ –Ω—É–∂–Ω—ã–π –º–æ–º–µ–Ω—Ç!
      </p>
    </header>
    <section class="hud">
      <div class="stat">
        <span class="stat__label">–£–≥–æ—â–µ–Ω–∏—è ü•©</span>
        <span class="stat__value"><span id="treats">0</span><span class="stat__accent" id="treatProgressLabel">0 / 10</span></span>
      </div>
      <div class="stat">
        <span class="stat__label">–•–æ–¥—ã</span>
        <span class="stat__value" id="moves">0</span>
      </div>
      <div class="stat">
        <span class="stat__label">–û—á–∫–∏</span>
        <span class="stat__value" id="score">0</span>
      </div>
      <div class="stat">
        <span class="stat__label">–¢–∞–π–º–µ—Ä</span>
        <span class="stat__value"><span id="timer">01:00</span></span>
      </div>
    </section>
    <div class="progress" aria-hidden="true"><div id="progressFill" class="progress__fill"></div></div>
    <div class="tools">
      <button id="openChest" type="button">üéÅ –û—Ç–∫—Ä—ã—Ç—å —Å—É–Ω–¥—É–∫</button>
      <div class="tools__counter">–°—É–Ω–¥—É–∫–∏: <strong id="chestCount">0</strong></div>
      <button id="rewind" type="button">‚Ü∫ –û—Ç–∫–∞—Ç</button>
      <button id="newGame" type="button">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
    </div>
    <section class="inventory">
      <h2>–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å –ø–ª–∏—Ç–æ–∫</h2>
      <div id="inventoryList" class="inventory__list" role="list"></div>
      <p class="inventory__hint">–û—Ç–∫—Ä–æ–π —Å—É–Ω–¥—É–∫, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –ø–ª–∏—Ç–∫—É. –ö–ª–∏–∫–Ω–∏ –ø–æ –ø–ª–∏—Ç–∫–µ –≤ –∏–Ω–≤–µ–Ω—Ç–∞—Ä–µ, –∑–∞—Ç–µ–º –ø–æ –∫–ª–µ—Ç–∫–µ –Ω–∞ –ø–æ–ª–µ, —á—Ç–æ–±—ã –∑–∞–º–µ–Ω–∏—Ç—å –µ—ë.</p>
    </section>
  </section>
</div>
<div id="toast" class="toast" role="status" aria-live="polite">–ü–æ–¥—Å–∫–∞–∑–∫–∞</div>
<script>
const N = 8;
const TYPES = [1,2,3,4,5,6];
const SCORE_PER_TILE = 10;
const DRAG_THRESHOLD = 18;
const GAME_TIME = 60;

let grid = [];
let score = 0;
let moves = 0;
let treats = 0;
let treatProgress = 0;
let chests = 0;
let inventory = [];
let selected = null;
let selectedInventoryIndex = null;
let snapshotState = null;
let dragging = false;
let dragInfo = null;
let suppressClick = false;
let boardLocked = false;
let gameOver = false;
let timerId = null;
let timeLeft = GAME_TIME;

const board = document.getElementById('board');
const toastEl = document.getElementById('toast');
const scoreEl = document.getElementById('score');
const movesEl = document.getElementById('moves');
const treatsEl = document.getElementById('treats');
const treatProgressLabel = document.getElementById('treatProgressLabel');
const progressFill = document.getElementById('progressFill');
const chestCountEl = document.getElementById('chestCount');
const inventoryList = document.getElementById('inventoryList');
const timerEl = document.getElementById('timer');
const overlay = document.getElementById('overlay');
const overlaySummary = document.getElementById('overlaySummary');
const overlayRestart = document.getElementById('overlayRestart');

function toast(msg, ms=1600){
  toastEl.textContent = msg;
  toastEl.classList.add('show');
  setTimeout(()=>toastEl.classList.remove('show'), ms);
}
const rand = n => Math.floor(Math.random()*n);
const delay = ms => new Promise(r=>setTimeout(r,ms));
function inb(r,c){ return r>=0 && c>=0 && r<N && c<N; }
function neighbors(a,b){ return (a.r===b.r && Math.abs(a.c-b.c)===1) || (a.c===b.c && Math.abs(a.r-b.r)===1); }

function borderFor(type){
  const colors = {
    1:'#6aa4ff',
    2:'#3bd88f',
    3:'#ffbf5e',
    4:'#ff6a7a',
    5:'#b28bff',
    6:'#3ce8ff'
  };
  return colors[type] || '#d1d9ff';
}
function candidatePaths(base){
  return [`${base}.png`, `${base}.PNG`, `${base}.Png`];
}
function setImgFallback(img, base){
  const paths = candidatePaths(base);
  let i = 0;
  img.onerror = ()=>{ i++; if(i < paths.length) img.src = paths[i]; };
  img.src = paths[i];
}
function buildDOM(){
  board.style.gridTemplateColumns = `repeat(${N}, var(--tile))`;
  board.innerHTML = '';
  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      const tile = document.createElement('div');
      tile.className = 'tile';
      tile.dataset.r = r;
      tile.dataset.c = c;
      const img = document.createElement('img');
      tile.appendChild(img);
      cell.appendChild(tile);
      board.appendChild(cell);
    }
  }
}
function renderCell(r,c){
  const tile = board.children[r*N + c].firstChild;
  tile.classList.toggle('selected', !!selected && selected.r===r && selected.c===c);
  const data = grid[r][c];
  if(!data){
    tile.firstChild.removeAttribute('src');
    tile.style.borderColor = 'transparent';
    return;
  }
  setImgFallback(tile.firstChild, String(data.type));
  tile.style.borderColor = borderFor(data.type);
}
function renderAll(){
  for(let r=0;r<N;r++) for(let c=0;c<N;c++) renderCell(r,c);
}
function renderHUD(){
  scoreEl.textContent = score;
  movesEl.textContent = moves;
  treatsEl.textContent = treats;
  chestCountEl.textContent = chests;
  treatProgressLabel.textContent = `${treatProgress} / 10`;
  progressFill.style.width = `${(treatProgress/10)*100}%`;
}
function updateTimerUI(){
  const m = Math.floor(timeLeft/60);
  const s = timeLeft%60;
  timerEl.textContent = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
}
function updateInventoryUI(){
  inventoryList.innerHTML = '';
  if(!inventory.length){
    const placeholder = document.createElement('div');
    placeholder.className = 'inventory__empty';
    placeholder.textContent = '–ü–æ–∫–∞ –∑–¥–µ—Å—å –ø—É—Å—Ç–æ.';
    inventoryList.appendChild(placeholder);
    return;
  }
  inventory.forEach((type, idx)=>{
    const item = document.createElement('button');
    item.type = 'button';
    item.className = 'inventory__item';
    item.setAttribute('role','listitem');
    if(selectedInventoryIndex === idx) item.classList.add('active');
    const img = document.createElement('img');
    setImgFallback(img, String(type));
    item.appendChild(img);
    item.addEventListener('click', ()=>{
      if(selectedInventoryIndex === idx){
        selectedInventoryIndex = null;
      } else {
        selectedInventoryIndex = idx;
      }
      updateInventoryUI();
      if(selectedInventoryIndex !== null){
        toast('–í—ã–±–µ—Ä–∏—Ç–µ –∫–ª–µ—Ç–∫—É –Ω–∞ –ø–æ–ª–µ –¥–ª—è –∑–∞–º–µ–Ω—ã');
      }
    });
    inventoryList.appendChild(item);
  });
}
function randomTile(){
  return {type: TYPES[rand(TYPES.length)]};
}
function initGrid(){
  grid = Array.from({length:N}, ()=> Array.from({length:N}, randomTile));
  while(findMatches().length) shuffleBoard();
}
function shuffleBoard(){
  const list=[];
  for(let r=0;r<N;r++) for(let c=0;c<N;c++) list.push(grid[r][c]);
  for(let i=list.length-1;i>0;i--){ const j=rand(i+1); [list[i],list[j]]=[list[j],list[i]]; }
  let k=0;
  for(let r=0;r<N;r++) for(let c=0;c<N;c++) grid[r][c]=list[k++];
}
function snapshot(){
  snapshotState = JSON.stringify({grid, score, moves, treats, treatProgress, chests, inventory});
}
function restore(){
  if(!snapshotState || boardLocked) return;
  const s = JSON.parse(snapshotState);
  grid = s.grid;
  score = s.score;
  moves = s.moves;
  treats = s.treats;
  treatProgress = s.treatProgress;
  chests = s.chests;
  inventory = s.inventory;
  selected = null;
  selectedInventoryIndex = null;
  renderAll();
  renderHUD();
  updateInventoryUI();
  toast('‚Ü∫ –í–æ–∑–≤—Ä–∞—Ç —Ö–æ–¥–∞');
}
function findMatches(){
  const out=[];
  for(let r=0;r<N;r++){
    let run=1;
    for(let c=1;c<=N;c++){
      const prev=grid[r][c-1];
      const cur=(c<N?grid[r][c]:null);
      if(cur && prev && prev.type===cur.type){ run++; }
      else {
        if(run>=3){ out.push(Array.from({length:run},(_,i)=>({r, c:c-1-i}))); }
        run=1;
      }
    }
  }
  for(let c=0;c<N;c++){
    let run=1;
    for(let r=1;r<=N;r++){
      const prev=grid[r-1][c];
      const cur=(r<N?grid[r][c]:null);
      if(cur && prev && prev.type===cur.type){ run++; }
      else {
        if(run>=3){ out.push(Array.from({length:run},(_,i)=>({r:r-1-i, c}))); }
        run=1;
      }
    }
  }
  return out;
}
function addTreats(amount){
  if(amount<=0) return;
  treats += amount;
  treatProgress += amount;
  while(treatProgress >= 10){
    treatProgress -= 10;
    chests++;
    toast('üéÅ –ü–æ–ª—É—á–µ–Ω —Å—É–Ω–¥—É–∫!');
  }
}
async function crush(matches){
  if(!matches.length) return false;
  const seen = new Set();
  let removed = 0;
  for(const group of matches){
    if(group.length===3) addTreats(1);
    else if(group.length===4) addTreats(2);
    else if(group.length>=5) addTreats(3);
    for(const p of group){
      const key = `${p.r},${p.c}`;
      if(!seen.has(key)){
        seen.add(key);
        if(grid[p.r][p.c]){
          grid[p.r][p.c] = null;
          removed++;
        }
      }
    }
  }
  score += removed * SCORE_PER_TILE;
  renderHUD();
  await collapseAndRefill();
  renderAll();
  const cascade = findMatches();
  if(cascade.length) await crush(cascade);
  return true;
}
async function collapseAndRefill(){
  for(let c=0;c<N;c++){
    let write = N-1;
    for(let r=N-1;r>=0;r--){
      if(grid[r][c]){
        grid[write][c] = grid[r][c];
        if(write!==r) grid[r][c]=null;
        write--;
      }
    }
    for(let r=write;r>=0;r--){
      grid[r][c] = randomTile();
    }
  }
}
function setSelected(p){
  const prev = selected;
  selected = p;
  if(prev) renderCell(prev.r, prev.c);
  if(p) renderCell(p.r, p.c);
}
function getTileEl(pos){
  return board.children[pos.r*N + pos.c].firstChild;
}
function animateSwap(a,b,{revert=false,onArrive}={}){
  return new Promise(resolve=>{
    const tileA = getTileEl(a);
    const tileB = getTileEl(b);
    const rectA = tileA.getBoundingClientRect();
    const rectB = tileB.getBoundingClientRect();
    const ghostA = tileA.cloneNode(true);
    const ghostB = tileB.cloneNode(true);
    ghostA.classList.add('tile-ghost');
    ghostB.classList.add('tile-ghost');
    const styleA = getComputedStyle(tileA);
    const styleB = getComputedStyle(tileB);
    ghostA.style.width = rectA.width+'px';
    ghostA.style.height = rectA.height+'px';
    ghostB.style.width = rectB.width+'px';
    ghostB.style.height = rectB.height+'px';
    ghostA.style.left = rectA.left+'px';
    ghostA.style.top = rectA.top+'px';
    ghostB.style.left = rectB.left+'px';
    ghostB.style.top = rectB.top+'px';
    ghostA.style.borderColor = styleA.borderColor;
    ghostB.style.borderColor = styleB.borderColor;
    ghostA.style.boxShadow = styleA.boxShadow;
    ghostB.style.boxShadow = styleB.boxShadow;
    ghostA.style.transform = 'translate(0,0)';
    ghostB.style.transform = 'translate(0,0)';
    tileA.classList.add('tile--ghost');
    tileB.classList.add('tile--ghost');
    document.body.appendChild(ghostA);
    document.body.appendChild(ghostB);
    const dx = rectB.left - rectA.left;
    const dy = rectB.top - rectA.top;
    requestAnimationFrame(()=>{
      ghostA.style.transform = `translate(${dx}px, ${dy}px)`;
      ghostB.style.transform = `translate(${-dx}px, ${-dy}px)`;
    });
    function forwardEnd(e){
      if(e.propertyName !== 'transform') return;
      ghostA.removeEventListener('transitionend', forwardEnd);
      if(onArrive) onArrive();
      if(revert){
        requestAnimationFrame(()=>{
          ghostA.style.transform = 'translate(0,0)';
          ghostB.style.transform = 'translate(0,0)';
        });
        ghostA.addEventListener('transitionend', backEnd);
      } else {
        cleanup();
      }
    }
    function backEnd(e){
      if(e.propertyName !== 'transform') return;
      ghostA.removeEventListener('transitionend', backEnd);
      cleanup();
    }
    function cleanup(){
      ghostA.remove();
      ghostB.remove();
      tileA.classList.remove('tile--ghost');
      tileB.classList.remove('tile--ghost');
      resolve();
    }
    ghostA.addEventListener('transitionend', forwardEnd);
  });
}
function evaluateSwap(a,b){
  const pa = grid[a.r][a.c];
  const pb = grid[b.r][b.c];
  grid[a.r][a.c] = pb;
  grid[b.r][b.c] = pa;
  const matches = findMatches();
  grid[a.r][a.c] = pa;
  grid[b.r][b.c] = pb;
  return matches;
}
function performSwap(a,b){
  const temp = grid[a.r][a.c];
  grid[a.r][a.c] = grid[b.r][b.c];
  grid[b.r][b.c] = temp;
  renderCell(a.r,a.c);
  renderCell(b.r,b.c);
}
async function attemptSwap(a,b){
  if(!neighbors(a,b) || boardLocked || gameOver) return;
  snapshot();
  const prospective = evaluateSwap(a,b);
  boardLocked = true;
  if(!prospective.length){
    await animateSwap(a,b,{revert:true});
    boardLocked = false;
    setSelected(null);
    suppressClick = true;
    return;
  }
  await animateSwap(a,b,{onArrive:()=>{ performSwap(a,b); }});
  moves++;
  renderHUD();
  setSelected(null);
  await crush(prospective);
  boardLocked = false;
  suppressClick = true;
}
function tryUseInventoryOn(r,c){
  if(selectedInventoryIndex===null || boardLocked || gameOver) return false;
  snapshot();
  const type = inventory[selectedInventoryIndex];
  inventory.splice(selectedInventoryIndex,1);
  selectedInventoryIndex = null;
  grid[r][c] = {type};
  updateInventoryUI();
  renderCell(r,c);
  setSelected(null);
  const matches = findMatches();
  if(matches.length){
    boardLocked = true;
    crush(matches).then(()=>{ boardLocked=false; });
  }
  renderHUD();
  return true;
}
function startTimer(){
  clearInterval(timerId);
  timeLeft = GAME_TIME;
  updateTimerUI();
  timerId = setInterval(()=>{
    if(timeLeft<=0){
      clearInterval(timerId);
      endGame();
      return;
    }
    timeLeft--;
    updateTimerUI();
    if(timeLeft<=0){
      clearInterval(timerId);
      endGame();
    }
  },1000);
}
function endGame(){
  gameOver = true;
  overlay.classList.add('visible');
  overlaySummary.textContent = `–í—ã —Å–æ–±—Ä–∞–ª–∏ ${treats} —É–≥–æ—â–µ–Ω–∏–π.`;
}
function closeOverlay(){
  overlay.classList.remove('visible');
}
function newGame(){
  closeOverlay();
  gameOver = false;
  boardLocked = false;
  score = 0;
  moves = 0;
  treats = 0;
  treatProgress = 0;
  chests = 0;
  inventory = [];
  selectedInventoryIndex = null;
  selected = null;
  snapshotState = null;
  buildDOM();
  initGrid();
  renderAll();
  renderHUD();
  updateInventoryUI();
  startTimer();
}

board.addEventListener('click',(e)=>{
  if(gameOver || boardLocked) return;
  if(suppressClick){ suppressClick=false; return; }
  const tile = e.target.closest('.tile');
  if(!tile) return;
  const r = +tile.dataset.r;
  const c = +tile.dataset.c;
  if(tryUseInventoryOn(r,c)) return;
  if(!selected){ setSelected({r,c}); return; }
  if(selected.r===r && selected.c===c){ setSelected(null); return; }
  if(neighbors(selected,{r,c})){
    attemptSwap(selected,{r,c});
  } else {
    setSelected({r,c});
  }
});
let activePointer = null;
board.addEventListener('pointerdown',(e)=>{
  if(gameOver || boardLocked || selectedInventoryIndex!==null) return;
  const tile = e.target.closest('.tile');
  if(!tile) return;
  activePointer = e.pointerId;
  board.setPointerCapture(activePointer);
  dragging = true;
  suppressClick = false;
  dragInfo = {r:+tile.dataset.r, c:+tile.dataset.c, x:e.clientX, y:e.clientY};
  setSelected({r:dragInfo.r, c:dragInfo.c});
});
board.addEventListener('pointermove',(e)=>{
  if(!dragging || activePointer!==e.pointerId || !dragInfo) return;
  const dx = e.clientX - dragInfo.x;
  const dy = e.clientY - dragInfo.y;
  if(Math.abs(dx)<DRAG_THRESHOLD && Math.abs(dy)<DRAG_THRESHOLD) return;
  const origin = {r:dragInfo.r, c:dragInfo.c};
  let target = null;
  if(Math.abs(dx) > Math.abs(dy)){
    target = {r:origin.r, c:origin.c + (dx>0?1:-1)};
  } else {
    target = {r:origin.r + (dy>0?1:-1), c:origin.c};
  }
  if(target && inb(target.r,target.c)){
    dragging = false;
    dragInfo = null;
    suppressClick = true;
    board.releasePointerCapture(activePointer);
    activePointer = null;
    attemptSwap(origin, target);
  }
});
board.addEventListener('pointerup',(e)=>{
  if(activePointer === e.pointerId){
    board.releasePointerCapture(activePointer);
  }
  activePointer = null;
  dragging = false;
  dragInfo = null;
});
board.addEventListener('pointercancel',()=>{
  if(activePointer!==null) board.releasePointerCapture(activePointer);
  activePointer=null;
  dragging=false;
  dragInfo=null;
});

document.getElementById('newGame').addEventListener('click',()=>{ newGame(); });
document.getElementById('rewind').addEventListener('click',()=>{ restore(); });
document.getElementById('openChest').addEventListener('click',()=>{
  if(gameOver) return;
  if(chests<=0){ toast('–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å—É–Ω–¥—É–∫–æ–≤'); return; }
  snapshot();
  chests--;
  const type = TYPES[rand(TYPES.length)];
  inventory.push(type);
  renderHUD();
  updateInventoryUI();
  toast('–°—É–Ω–¥—É–∫ –æ—Ç–∫—Ä—ã—Ç! –ù–æ–≤–∞—è –ø–ª–∏—Ç–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å.');
});
overlayRestart.addEventListener('click',()=>{ newGame(); });
overlay.addEventListener('click',(e)=>{
  if(e.target===overlay) newGame();
});

newGame();
</script>
</body>
</html>
